<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<style>
			body { margin: 0; }
		</style>
         <link href="./texture_demo.css" rel="stylesheet" type="text/css"/>
	</head>
	<body>
        <div class="wrapper">
        <div id="textureCanvas"></div>
        <div id="textureDetail"></div>
        <div id="textureModified">
                Geometry 
            <select id="geometrySelect">
                <option value="cube">Cube</option>
                <option value="sphere">Sphere</option>
            </select>
            
            <div>
                Roughness <input type="range" min="0" max="100" value="70"/></div>
            <div>
                Opacity <input type="range" min="0" max="100" value="70" id="opacity"/></div>
            <div>
                Metaleness <input type="range" min="0" max="100" value="70"/></div>
            <div>
                Color <input type="color" value="#e66465"/></div>

        
        </div>
        </div>
        
		<script src="three.js"></script>
		<script type="module">
                  import { OrbitControls } from '/viewhelper/OrbitControls.js';
            

            //let mesh, renderer, scene, camera, controls, controlsGizmo;
			const scene = new THREE.Scene();
			const camera = new THREE.PerspectiveCamera( 75, document.getElementById("textureCanvas").clientWidth/ document.getElementById("textureCanvas").clientHeight, 0.1, 1000 );
            
            camera.position.set( 400, 200, 0 );

			const renderer = new THREE.WebGLRenderer();
            renderer.setClearColor(new THREE.Color(0x4c4b4b));
			renderer.setSize( document.getElementById("textureCanvas").clientWidth, document.getElementById("textureCanvas").clientHeight );
			document.getElementById("textureCanvas").appendChild( renderer.domElement );
            
            const controls = new OrbitControls( camera, renderer.domElement );
            controls.enableDamping = true; // an animation loop is required when either damping or auto-rotation are enabled
            controls.dampingFactor = 0.05;

			controls.screenSpacePanning = false;

            controls.minDistance = 200;
            controls.maxDistance = 300;

            controls.maxPolarAngle = Math.PI / 2;
            
            const geometry = new THREE.BoxGeometry( 200, 200, 200 );
            const material = new THREE.MeshPhongMaterial( { color: 0xffffff, flatShading: true } );


				const mesh = new THREE.Mesh( geometry, material );
				mesh.position.x = 0;
				mesh.position.y = 0;
				mesh.position.z = 0;
				mesh.updateMatrix();
				mesh.matrixAutoUpdate = false;
				scene.add( mesh );


				// lights

				const dirLight1 = new THREE.DirectionalLight( 0xffffff );
				dirLight1.position.set( 1, 1, 1 );
				scene.add( dirLight1 );

				const dirLight2 = new THREE.DirectionalLight( 0x002288 );
				dirLight2.position.set( - 1, - 1, - 1 );
				scene.add( dirLight2 );

				const ambientLight = new THREE.AmbientLight( 0x222222 );
				scene.add( ambientLight );


			function animate() {
				requestAnimationFrame( animate );
                window.onresize = resize;
				renderer.render( scene, camera );
			};

			animate();
            
            function resize() {
                const container = document.getElementById( 'textureCanvas' );
                renderer.setSize( container.clientWidth, container.clientHeight );
                camera.aspect = ( container.clientWidth/container.clientHeight);
                camera.updateProjectionMatrix();
            }

		</script>
	</body>
</html>
